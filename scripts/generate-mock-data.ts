import { faker } from '@faker-js/faker';
import {
  User,
  Chapter,
  CubeEvent,
  Role,
  OnboardingStatus,
  EventStatus,
  ParticipantStatus,
  OutreachOutcome,
  AnnouncementScope,
  ResourceType,
  SkillLevel,
  TourDuty,
  OutreachLog,
  Announcement,
  Resource,
  Notification,
  NotificationType,
} from '../src/types';
import { nanoid } from 'nanoid';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// --- CONFIGURATION ---
const NUM_CHAPTERS = 25;
const NUM_USERS = 400;
const EVENTS_PER_CHAPTER_MIN = 5;
const EVENTS_PER_CHAPTER_MAX = 15;
const ANNOUNCEMENTS = 30;
const RESOURCES = 20;

faker.seed(42);

// --- HELPERS ---
const writeDataToFile = (data: Record<string, unknown[]>) => {
  const content = `// This file is generated by scripts/generate-mock-data.ts
// Do not edit this file directly.
/* eslint-disable */
import { User, Chapter, CubeEvent, OutreachLog, Announcement, Resource, AccommodationRequest, EventComment, Challenge, Notification, BadgeAward, InventoryItem } from '../types';

${Object.entries(data)
      .map(([key, value]) => {
        // A simple way to type the exported arrays without importing all types here
        const typeMap: Record<string, string> = {
          users: 'User',
          chapters: 'Chapter',
          events: 'CubeEvent',
          outreachLogs: 'OutreachLog',
          announcements: 'Announcement',
          resources: 'Resource',
          accommodationRequests: 'AccommodationRequest',
          eventComments: 'EventComment',
          challenges: 'Challenge',
          notifications: 'Notification',
          badgeAwards: 'BadgeAward',
          inventory: 'InventoryItem',
        };
        const type = typeMap[key] || 'any';

        // Convert the data to use proper enum values and date objects
        const processedValue = processDataForExport(value);

        return `export const ${key}: ${type}[] = ${JSON.stringify(
          processedValue,
          null,
          2
        )};`;
      })
      .join('\n\n')}
`;
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);
  const outputPath = path.join(__dirname, '../src/data/mockData.ts');

  // Ensure the directory exists before writing the file
  const outputDir = path.dirname(outputPath);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
    console.log(`üìÅ Created directory: ${outputDir}`);
  }

  fs.writeFileSync(outputPath, content);
  console.log(`‚úÖ Mock data written to ${outputPath}`);
};

// Process data to use proper enum values and date objects
const processDataForExport = (data: unknown[]): Record<string, unknown>[] => {
  return data.map(item => {
    const processed: Record<string, unknown> = {};

    if (item && typeof item === 'object') {
      for (const [key, value] of Object.entries(item)) {
        if (key === 'role') {
          // Convert role strings to enum values
          processed[key] = value;
        } else if (key === 'onboardingStatus') {
          // Convert onboarding status strings to enum values
          processed[key] = value;
        } else if (key === 'startDate' || key === 'joinDate' || key === 'lastLogin' || key === 'createdAt') {
          // Convert date strings back to Date objects
          processed[key] = new Date(value as string);
        } else if (key === 'status') {
          // Convert event status strings to enum values
          processed[key] = value;
        } else if (key === 'outcome') {
          // Convert outreach outcome strings to enum values
          processed[key] = value;
        } else if (key === 'scope') {
          // Convert announcement scope strings to enum values
          processed[key] = value;
        } else if (key === 'type') {
          // Convert resource type strings to enum values
          processed[key] = value;
        } else if (key === 'skillLevel') {
          // Convert skill level strings to enum values
          processed[key] = value;
        } else if (key === 'participants') {
          // Handle nested participants array
          if (Array.isArray(value)) {
            processed[key] = value.map((participant: Record<string, unknown>) => ({
              ...participant,
              user: participant.user,
              status: participant.status,
              tourDuties: participant.tourDuties || []
            }));
          } else {
            processed[key] = value;
          }
        } else if (key === 'organizer') {
          // Handle organizer object
          processed[key] = value;
        } else if (key === 'author') {
          // Handle author object
          processed[key] = value;
        } else {
          // Keep other values as-is
          processed[key] = value;
        }
      }
    }

    return processed;
  });
};

// --- GENERATORS ---

const generateChapters = (count: number): Chapter[] => {
  return Array.from({ length: count }, () => ({
    name: faker.location.city(),
    country: faker.location.country(),
    lat: faker.location.latitude(),
    lng: faker.location.longitude(),
    instagram: `@av_${faker.lorem.word()}`,
  }));
};

const generateUsers = (count: number, chapters: Chapter[]): User[] => {
  const users: User[] = [];
  for (let i = 0; i < count; i++) {
    const name = faker.person.fullName();
    const userChapters = faker.helpers.arrayElements(
      chapters.map((c) => c.name),
      { min: 1, max: 2 }
    );
    const onboardingStatus = faker.helpers.weightedArrayElement([
      { weight: 70, value: OnboardingStatus.CONFIRMED },
      { weight: 10, value: OnboardingStatus.PENDING_APPLICATION_REVIEW },
      { weight: 10, value: OnboardingStatus.AWAITING_FIRST_CUBE },
      { weight: 5, value: OnboardingStatus.PENDING_ONBOARDING_CALL },
      { weight: 5, value: OnboardingStatus.DENIED },
    ]);

    const role =
      onboardingStatus === OnboardingStatus.CONFIRMED
        ? faker.helpers.weightedArrayElement([
          { weight: 80, value: Role.ACTIVIST },
          { weight: 15, value: Role.CHAPTER_ORGANISER },
          { weight: 5, value: Role.REGIONAL_ORGANISER },
        ])
        : Role.APPLICANT;

    const user: User = {
      id: nanoid(),
      name,
      email: faker.internet.email({ firstName: name.split(' ')[0] }),
      role,
      chapters: userChapters,
      onboardingStatus,
      profilePictureUrl: `https://i.pravatar.cc/150?u=${nanoid()}`,
      joinDate: faker.date.past({ years: 3 }),
      lastLogin: faker.date.recent({ days: 90 }),
      stats: {
        totalHours: faker.number.int({ min: 0, max: 500 }),
        cubesAttended: faker.number.int({ min: 0, max: 100 }),
        veganConversions: faker.number.int({ min: 0, max: 50 }),
        totalConversations: faker.number.int({ min: 0, max: 1000 }),
        cities: userChapters,
      },
      badges: [],
      hostingAvailability: faker.datatype.boolean(),
      hostingCapacity: faker.number.int({ min: 1, max: 5 }),
    };

    if (onboardingStatus !== OnboardingStatus.CONFIRMED) {
      user.onboardingAnswers = {
        veganReason: faker.lorem.paragraph(),
        abolitionistAlignment: faker.datatype.boolean({ probability: 0.8 }), // 80% chance of being true
        customAnswer: faker.lorem.paragraph(),
      };
    }

    if (user.role === Role.CHAPTER_ORGANISER) {
      user.organiserOf = [userChapters[0]];
    }
    if (user.role === Role.REGIONAL_ORGANISER) {
      const chapter = chapters.find((c) => c.name === userChapters[0]);
      if (chapter) user.managedCountry = chapter.country;
    }

    users.push(user);
  }
  return users;
};

const generateEvents = (
  chapters: Chapter[],
  users: User[]
): CubeEvent[] => {
  const events: CubeEvent[] = [];
  const confirmedUsers = users.filter(
    (u) => u.onboardingStatus === OnboardingStatus.CONFIRMED
  );

  chapters.forEach((chapter) => {
    const eventCount = faker.number.int({
      min: EVENTS_PER_CHAPTER_MIN,
      max: EVENTS_PER_CHAPTER_MAX,
    });
    const chapterMembers = confirmedUsers.filter((u) =>
      u.chapters.includes(chapter.name)
    );
    const chapterOrganiser =
      chapterMembers.find((u) => u.role === Role.CHAPTER_ORGANISER) ||
      chapterMembers[0];

    if (!chapterOrganiser) return;

    for (let i = 0; i < eventCount; i++) {
      const startDate = faker.date.between({
        from: new Date().setFullYear(new Date().getFullYear() - 1),
        to: new Date().setMonth(new Date().getMonth() + 2),
      });
      const isPast = startDate < new Date();
      const participants = faker.helpers
        .arrayElements(chapterMembers, {
          min: 5,
          max: Math.min(30, chapterMembers.length),
        })
        .map((user) => ({
          user,
          status: ParticipantStatus.ATTENDING,
          tourDuties: [] as TourDuty[],
        }));

      const event: CubeEvent = {
        id: nanoid(),
        name: `${chapter.name} Cube of Truth`,
        city: chapter.name,
        location: faker.location.streetAddress(),
        startDate,
        scope: 'Chapter',
        organizer: chapterOrganiser,
        participants,
        status: isPast ? EventStatus.FINISHED : EventStatus.UPCOMING,
        report: isPast
          ? {
            hours: faker.number.int({ min: 2, max: 6 }),
            attendance: Object.fromEntries(
              participants.map((p) => [
                p.user.id,
                faker.helpers.weightedArrayElement([
                  { weight: 9, value: 'Attended' },
                  { weight: 1, value: 'Absent' },
                ]),
              ])
            ),
          }
          : undefined,
      };
      events.push(event);
    }
  });

  return events;
};

const generateOutreachLogs = (users: User[], events: CubeEvent[]) => {
  const logs: OutreachLog[] = [];
  const pastEvents = events.filter((e) => e.status === EventStatus.FINISHED);

  pastEvents.forEach((event) => {
    event.participants.forEach((participant) => {
      if (
        event.report?.attendance[participant.user.id] === 'Attended' &&
        faker.datatype.boolean(0.8)
      ) {
        const logCount = faker.number.int({ min: 1, max: 15 });
        for (let i = 0; i < logCount; i++) {
          logs.push({
            id: nanoid(),
            userId: participant.user.id,
            eventId: event.id,
            outcome: faker.helpers.objectValue(OutreachOutcome),
            notes: faker.datatype.boolean(0.2)
              ? faker.lorem.sentence()
              : undefined,
            createdAt: event.startDate,
          });
        }
      }
    });
  });
  return logs;
};

const generateAnnouncements = (
  count: number,
  users: User[],
  chapters: Chapter[]
) => {
  const announcements: Announcement[] = [];
  const organizers = users.filter((u) =>
    [Role.CHAPTER_ORGANISER, Role.REGIONAL_ORGANISER, Role.GLOBAL_ADMIN].includes(
      u.role
    )
  );

  for (let i = 0; i < count; i++) {
    const author = faker.helpers.arrayElement(organizers);
    const scope = faker.helpers.arrayElement(
      Object.values(AnnouncementScope)
    );
    const announcement: Announcement = {
      id: nanoid(),
      author,
      scope,
      title: faker.lorem.sentence(),
      content: faker.lorem.paragraphs(2),
      createdAt: faker.date.past({ years: 1 }),
    };
    if (scope === 'Chapter') {
      announcement.chapter = faker.helpers.arrayElement(chapters).name;
    }
    if (scope === 'Regional') {
      announcement.country = faker.helpers.arrayElement(chapters).country;
    }
    announcements.push(announcement);
  }
  return announcements;
};

const generateResources = (count: number) => {
  const resources: Resource[] = [];
  for (let i = 0; i < count; i++) {
    resources.push({
      id: nanoid(),
      title: faker.company.catchPhrase(),
      description: faker.lorem.paragraph(),
      type: faker.helpers.objectValue(ResourceType),
      skillLevel: faker.helpers.objectValue(SkillLevel),
      language: faker.helpers.arrayElement(['English', 'Spanish', 'German']),
      url: 'https://example.com',
      icon: faker.helpers.arrayElement([
        'BookOpenIcon',
        'DocumentTextIcon',
        'VideoCameraIcon',
      ]),
    });
  }
  return resources;
};

const generateNotificationsForApplicants = (users: User[]): Notification[] => {
  const notifications: Notification[] = [];
  const applicants = users.filter(
    (u) => u.onboardingStatus === OnboardingStatus.PENDING_APPLICATION_REVIEW
  );
  const organizers = users.filter((u) => u.role === Role.CHAPTER_ORGANISER);

  applicants.forEach((applicant) => {
    applicant.chapters.forEach((chapterName) => {
      const chapterOrganizers = organizers.filter((org) =>
        org.organiserOf?.includes(chapterName)
      );

      chapterOrganizers.forEach((organizer) => {
        notifications.push({
          id: nanoid(),
          userId: organizer.id,
          type: NotificationType.NEW_APPLICANT,
          message: `${applicant.name} has applied to join the ${chapterName} chapter.`,
          linkTo: '/manage',
          isRead: false,
          createdAt: applicant.joinDate || new Date(),
          relatedUser: applicant,
        });
      });
    });
  });
  return notifications;
};

// --- MAIN ---

const generateAll = () => {
  const chapters = generateChapters(NUM_CHAPTERS);
  const users = generateUsers(NUM_USERS, chapters);
  const events = generateEvents(chapters, users);
  const outreachLogs = generateOutreachLogs(users, events);
  const announcements = generateAnnouncements(ANNOUNCEMENTS, users, chapters);
  const resources = generateResources(RESOURCES);
  const notifications = generateNotificationsForApplicants(users);

  writeDataToFile({
    chapters,
    users,
    events,
    outreachLogs,
    announcements,
    resources,
    // Add empty arrays for other types to prevent import errors
    accommodationRequests: [],
    eventComments: [],
    challenges: [],
    notifications,
    badgeAwards: [],
    inventory: [],
  });
};

generateAll();
